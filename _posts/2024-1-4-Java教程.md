---
layout : article
title : "Java教程"
---

## 抽象类

### 抽象类定义

Java语言提供了两种类：具体类和抽象类  
在Java中，abstract是抽象的意思，可以修饰类，成员方法  
abstract修饰类，就是抽象类，abstract修饰方法，就是抽象方法  
格式如下：

> 修饰符 abstract class 类名{  
> 修饰符 abstract 返回值类型 方法名称（形参列表）  
> }  
> 注意：一个类中有抽象方法的话，该类也要被abstract修饰，否则会报错  
> 示例：

``` java
//abstract修饰的抽象类
public abstract class People {
 
    //abstract修饰的抽象方法
    public abstract void eat();
}
```

特点

> - 修饰符必须为public或者protected,不能为private,因为创建了抽象类，就要被其>他类继承，设为private就无法被继承
> - 抽象类不能被实例化，只能通过普通子类来实现实例化  
>     如果一个普通子类继承于抽象父类，则该类一定要重写实现该父类的抽象方法，如果>>- 子类仍然的hi一个抽象类，也是允许的，就不必冲写父类的抽象方法，但必须用abstract修饰
> - 抽象级别：抽象类是对整体类的抽象，包括属性和方法
> - 抽象类是现有子类，将子类的共同属性和方法提取出来放在抽象类中，是一种从下往上的构建法则
> - 父类包含了子类集合的常见方法，但由于父类本身是抽象的，不能使用这些方法

#### 抽象方法

抽象类方法特点

> - 抽象方法中没有方法体
> - 抽象方法必须存在于抽象类中
> - 子类重写父类时，必须重写父类的所有抽象方法
> - 抽象方法不能使用private final static 来修饰，因为这些关键字都是和重写违背的

抽象方法代码例子：

```java
//abstract修饰的抽象类
public abstract class People {
 
 
    //普通方法，带 {} 方法体
    public void fun(){
        System.out.println("存在方法体的普通方法");
    }
 
 
    //abstract修饰的抽象方法，没有方法体 {},被abstract修饰
    public abstract void eat();
}
```

#### 抽象类举例

##### 例子1

```java
public class Cat {
 
    public void sleep(){
        System.out.println("我在睡觉");
    }
}

public class Dog{
 
    public void sleep(){
        System.out.println("我在睡觉");
    }
}

```

现在需要增加一个eat的行为，各动物吃的不一样

```java
//定义一个abstract修饰的抽象类
public abstract class Animal {
 
    //通用的行为sleep也放在父类中
    public void sleep(){
        System.out.println("我在睡觉");
    }
    
    //定义抽象方法
    //抽象方法没有方法体{}
    public abstract void eat();
}


public class Cat extends Animal{
 
    //@Override注解是重写父类的方法
   @Override
    public void eat(){
       System.out.println("我在吃鱼");
   }
}

public class Dog extends Animal{
 
    //@Override注解是重写父类方法需要引入的注解
    @Override
    public void eat(){
        System.out.println("我在吃骨头");
    }
 
}
```

## 接口

### 接口定义

英文称作_**interface**_，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。

```java
[public] interface InterfaceName {
  void method1();
  void method2();
}
```

> - 接口中可以含有变量和方法
> - 变量会被隐式地指定为_**public static final**_变量,并且只能是public static final变量，用private修饰会报编译错误
> - 方法会被隐式地指定为_**public abstract**_方法且只能是public abstract方法,用其他关键字，比如private、protected、static、 final等修饰会报编译错误
> - 并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比**抽象类**更加“抽象”，并且一般情况下不在接口中定义变量。

### 接口实现

```java
Class MyClass \[extends Class 父类\] Implements 接口1，接口2，…接口N{

// @Override 接口方法

}
```

#### 接口举例

继续上文的例子使用接口重构

```java
//定义一个abstract修饰的抽象类
public abstract class Animal {
 
    //通用的行为sleep也放在父类中
    public void sleep(){
        System.out.println("我在睡觉");
    }
}
// 定义一个吃的接口
public interface IEat{
    void eat();
}


public class Cat extends Animal implements IEat{
 
    //@Override注解是重写父类的方法
   @Override
    public void eat(){
       System.out.println("我在吃鱼");
   }
}

public class Dog extends Animal  implements IEat{
 
    //@Override注解是重写父类方法需要引入的注解
    @Override
    public void eat(){
        System.out.println("我在吃骨头");
    }
 
}
```

## 抽象类和接口区别

### 1.语法层面上的区别

  1）抽象类可以提供成员方法的**实现细节**，而接口中只能存在_**public abstract 方法**_；

  2）抽象类中的成员变量可以是**各种类型**的，而接口中的成员变量只能是**public static final类型**的；

  3）接口中**不能**含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

  4）一个类只能继承**一个**抽象类，而一个类却可以实现**多个**接口。

### 2.设计层面上的区别

  1）抽象类是对一种_**事物**_的抽象，即对类抽象，而接口是对_**行为**_的抽象。

  抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

  举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将_**飞行**_这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将_**飞行**_设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个"是不是"的关系，而接口实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

  2）设计层面不同，抽象类作为很多子类的父类，它是一种_**模板式**_设计。而接口是一种行为规范，它是一种_**辐射式**_设计。

  什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。

  而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

　　   下面看一个网上流传最广泛的例子：

  门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：

```java
abstract class Door {
    public abstract void open();
    public abstract void close();
}
　　或者：
interface Door {
    public abstract void open();
    public abstract void close();
}
```

  但是现在如果我们需要门具有报警alarm()的功能，那么该如何实现？下面提供两种思路：

  1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

  2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open()和close()，也许这个类根本就不具备open()和close()这两个功能，比如火灾报警器。

  从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

```java
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法

## 拆箱装箱基本概念

- 什么是装箱和拆箱  
      Java中的装箱（boxing）和拆箱（unboxing）是指将基本数据类型与其对应的包装类之间进行转换的过程。

- 装箱  
      装箱是将基本数据类型转换为其对应的包装类，例如将int类型转换为Integer类型。这个过程是通过自动装箱（autoboxing）或手动装箱（manual boxing）完成的。自动装箱是指Java编译器自动将基本类型转换为包装类型，而手动装箱则是通过调用包装类的构造函数来完成。

- 拆箱  
      拆箱是将包装类转换为其对应的基本数据类型，例如将Integer类型转换为int类型。这个过程也是通过自动拆箱（autounboxing）或手动拆箱（manual unboxing）完成的。自动拆箱是指Java编译器自动将包装类型转换为基本类型，而手动拆箱则是通过调用包装类的xxxValue()方法来完成。

## 包装类型的必要性

- 基本类型包装列表

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/1702955066153image.png)

- 对象引用：基本类型不是对象，无法使用对象引用，而包装类型是对象，可以通过引用来操作。
- 泛型：泛型不能使用基本数据类型，必须使用包装类型。如,使用`List<Integer>`来存储一组整数，而不是使用`List<int>`。
- null值：基本类型不能为null，而包装类型可以为null。
- 类型转换：包装类型提供了许多类型转换方法，例如将字符串转换为整数或浮点数等，这些方法非常方便。
- 方法重载：方法重载可以使用不同的参数类型，但是基本数据类型和其对应的包装类型在方法中被认为是相同的类型，因此可以在方法中使用它们进行重载。

## 装箱和拆箱举例

从Java 5开始，引入了自动装箱和拆箱机制。这意味着我们可以直接将基本数据类型赋值给对应的封装类型变量，或将封装类型变量赋值给对应的基本数据类型变量，编译器会自动完成转换。例如：

```java
int x = 10;
Integer y = x;  // 自动装箱
int z = y;  // 自动拆箱
int x = y.intValue();  // JDK1.5 之前 手动拆箱
```

## 缓存池问题

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

## 包装类常用方法

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/1702955213936image.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021017.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021108.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021204.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021239.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021321.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021400.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021421.png)

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021447.png)

## String 和 StringBuilder、StringBuffer

### String

String 被声明为 final，因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```

****不可变的好处：****

- 1.可以缓存 hash 值  
    因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
- 2.String Pool 的需要  
    如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021527.png)

- 3.安全性  
    String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

- 4.线程安全  
    String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

****字符串的两种比较方式：==；equals()****  
\==比较的是；两个String对象地址空间是否相等，判断的是地址值；  
equals()判断String类型的内容是否相等。开发中 我们一般用的是equals()方法

### StringBuilder 和 StringBuffer

当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。

- StringBuffer

StringBuffer 对象 代表一个可变的字符串序列，当一个 StringBuffer 被创建以后，通过 StringBuffer 的一系列方法可以实现字符串的拼接、截取等操作。一旦通过 StringBuffer 生成了最终想要的字符串后，就可以调用其 toString 方法来生成一个新的字符串。例如

```java
StringBuffer testString= new StringBuffer("111");
testString.append("222");
System.out.println(testString);
```

append方法增加synchronized关键字保证了线程安全

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021615.png)

- StringBuilder

StringBuilder 其实是和 StringBuffer 几乎一样，只不过 StringBuilder 是非线程安全的

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/20240113021646.png)

_**使用场景：**_

错误方式：

```java
String builder = new String("aaa");
for (int i = 0; i < 10000; i++) {
    builder+="bbb"; // 每次循环都new StringBuilder().append()
}
builder.toString();
```

正确方式：

```java
String builder = new String("aaa");
for (int i = 0; i < 10000; i++) {
    builder+="bbb"; // 每次循环都new StringBuilder().append()
}
builder.toString();
```

## (一) 匿名类

### 概念

匿名类指的是没有类名的类，通常是通过继承或实现一个接口来实现的。匿名类的主要作用是简化代码，使代码更加简洁，易于阅读和编写。但是由于其特殊性质，匿名类的使用也较为复杂，需要仔细理解和掌握。

匿名类最早出现在Java的内部类中，但是自从Java 8中引入了Lambda表达式之后，匿名类也几乎被广泛应用于函数式编程中

### 语法

匿名类的语法比较简单，通常通过继承或实现一个接口来创建。下面是匿名类的基本语法：

```java
new SuperClass() {
 // 匿名类的成员定义
}
//或者
new Interface() {
 // 匿名类的成员定义
}
```

### 应用举例

\-排序和过滤  
在Java的集合框架中，可以使用匿名类来实现自定义的排序和过滤器。下面是一个使用匿名类对数组进行排序的例子：

```java
Arrays.sort(array, new Comparator() {
 public int compare(String s1, String s2) {
 return s1.compareTo(s2);
 }
});
```

\-lambda 表达  
自从Java 8中引入了Lambda表达式之后，匿名类在函数式编程中的应用越来越广泛。Lambda表达式可以替代匿名类，并且其语法更加简洁明了。下面是一个使用Lambda表达式实现排序的例子：

```java
Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));
```

### 匿名类的优缺点

- 优点  
    匿名类最大的优点是可以简化代码，使代码更加简洁，易于阅读和编写。此外，匿名类还可以在其定义的作用域之外访问外部变量和方法。

- 缺点  
    匿名类的缺点是在调试和维护时比较困难，因为无法直接查看匿名类的代码。而且匿名类无法重载，也无法定义构造方法，无法进行复杂的初始化操作

## (二)内部类

### 内部类概念

在一个类的内部定义一个类或者方法内，这样类成为内部类，内部类可以有效的控制类的访问控制以及方便内部类对宿主类成员和方法访问，编译后生成的class会体现宿主类名比如 AClass$InnerClass.class。  
内部类可分为:静态内部类、实例内部类、匿名内部类、局部内部类。其中的局部内部类是在方法里面定义的类，几乎不用。

### 内部类语法

```java
//这是一个外部类
class OutClass {
    //这是一个普通内部类
    class NeiBuClass {
        
    }
}
```

### 例子

- 普通内部类

```java
class OutClass {
    public int num1;
    private int num2;
    protected int num3;
    public void fun() {
        System.out.println("今天过得很开心!");
    }
    class NeiBuClass {
        public void show() {
            //外部类里的任何属性都内被内部类使用
            num1 = 1;
            num2 = 2;
            num3 = 3;
            System.out.println(num1+" "+num2+" "+num3);
            //访问外部类成员方法
            fun();
        }
    }
}
public class Test {
    public static void main(String[] args) {
        //实例化内部类前得先实例化外部类
        OutClass.NeiBuClass neiBuClass = new OutClass().new NeiBuClass();
        neiBuClass.show();
    }
}
```

- 静态内部类

```java
//外部类
class OutClass {
    //外部类成员
    public int num1 = 10;
    private int num2 = 20;
    protected int num3 = 30;
    public static int num4 = 40;
    //静态内部类
    static class NeiBuClass {
        public void show() {
            //实例化一个外部类对象  直接访问将会出错【注意区分普通内部类】
            OutClass outClass = new OutClass();
            //通过外部类对象来引用外部类属性
            System.out.println(outClass.num1);
            System.out.println(outClass.num2);
            System.out.println(outClass.num3);
            System.out.println(num4);
        }
    }
}
 
public class Test {
    public static void main(String[] args) {
        //创造一个静态内部类对象
        OutClass.NeiBuClass neiBuClass = new OutClass.NeiBuClass();
        neiBuClass.show();
    }
}

```

- 匿名内部类

```java
//定义一个名为IUSB的接口
interface IUSB {
    void show();
}
//Try类使用了这个接口
class Try implements IUSB{
    //重写了接口中的show方法
    @Override
    public void show() {
        System.out.println("今天你开心吗?");
    }
}
 
public class Test {
    public static void main(String[] args) {
        //new一个接口
        new IUSB() {
            @Override
            public void show() {
                System.out.println("这就是一个匿名内部类");
            }
        }.show();
    }
}
```

- 局部内部类

```java
public class Test {
    //一个名为show的方法
    public void show() {
        //这是一个局部内部类
        class Dog {
            //局部内部类的成员变量
            public int num = 10;
            //局部内部类中的成员方法
            public void fun() {
                System.out.println("这是局部内部类中的fun()方法");
            }
        }
        //实例化一个局部内部类对象
        Dog dog = new Dog();
        //通过dog引用来方法这两个属性
        System.out.println(dog.num);
        dog.fun();
    }
    public static void main(String[] args) {
        //再通过实例化一个主类才能调用show方法
        Test test = new Test();
        test.show();
    }
}
```
